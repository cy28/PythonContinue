
"""
在 Python 中，生成器是一种特殊的迭代器，它使用了一种称为“惰性计算”的技术，可以逐个地生成序列中的值，而不必一次性生成整个序列。
这种特性使得生成器非常适合处理大数据集合或者无限序列，因为只有在需要时才会生成下一个元素，而不是在一开始就将整个序列都生成出来。

总结:
     生成器 generator
1. 定义生成器的方式:
    a. 通过列表推导式的方式, 将[]改为()
    g = (x+1 for x in range(6))
    b. 函数 + yield
    denf func():
        ........
        yield
2. 产生元素的方式
    a. next(g)
    每次调用都会产生一个新的元素, 如果元素产生完毕, 再次调用就会产生异常
    b. g.__next__
    c. g.send(value)
"""

# 生成器可以通过两种方式创建：

# 1. 生成器表达式：类似于列表推导式，但使用圆括号而不是方括号，例如：
# 生成由 0 到 9 的平方组成的生成器
g = (x * x for x in range(10))
print(type(g))  # <class 'generator'>
print(g)  # <generator object <genexpr> at 0x000002425D0066C0>

# 调用方式1 通过__next__()方式得到元素
print(g.__next__())  # 0
print(g.__next__())  # 1
print(g.__next__())  # 4

# 调用方式2 通过next()得到元素 builtins 系统内置函数
print(next(g))  # 9
print(next(g))  # 16

print('------------------------------------------------分隔符----------------------------------------------------')

# 2. 函数生成器：使用关键字 yield 来定义生成器函数，例如：
# 生成由 0 到 n 的平方组成的生成器
def square(n):
    for i in range(n):
        yield i * i

# 调用生成器函数来获取生成器
h = square(10)
# 对于生成器对象，可以使用 next() 函数来逐个获取其生成的元素，例如：

# 获取生成器 g 中的元素
print(next(h))  # 输出 0
print(next(h))  # 输出 1
print(next(h)) # 输出 4
print(next(h))  # 输出 9
# ...
# 当生成器中没有更多的元素可生成时，会引发 StopIteration 异常。此时，如果仍然调用 next() 函数，就会抛出该异常。

# 另外，生成器还可以使用 for 循环来逐个获取其中的元素，例如：
# 通过 for 循环遍历生成器 g 中的元素
for x in h:
    print(x)
# 这种方式可以避免手动调用 next() 函数，并且在生成完所有元素后自动停止循环，避免了抛出 StopIteration 异常。


# send()方法

# 举例1
"""
在 Python 中，生成器对象除了使用 next() 方法逐个获取元素外，还可以使用 send() 方法向其发送一个值，并且在生成器函数中使用 yield 关键字来接收该值。
这种方式可以在生成器对象中传递信息，实现更加灵活的生成器。下面是一个简单的示例，其中定义了一个生成器函数 counter()，
用于生成一个无限序列，每次生成的元素为当前计数器的值，每次调用 next() 方法都会递增计数器。
此外，该生成器函数还定义了一个变量 delta，用于保存每次调用 send() 方法时传入的值，用于修改计数器的递增步长。
"""

def counter():
    i = 0
    delta = 1
    while True:
        val = yield i  # 接收 send() 方法发送的值，并返回当前计数器的值
        if val is not None:  # 如果接收到的值不是 None，就更新计数器的递增步长
            delta = val
        i += delta  # 更新计数器的值

# 创建生成器对象
c = counter()

# 使用 next() 方法获取生成器中的元素，输出 0
print(next(c))

# 使用 send() 方法向生成器发送一个值 3，并获取生成器中的下一个元素，输出 3 (3+0)
print(c.send(3))

# 再次使用 send() 方法向生成器发送一个值 5，并获取生成器中的下一个元素，输出 8 (3+5)
print(c.send(5))

# 使用 next() 方法获取生成器中的下一个元素，输出 13 (5+8)
print(next(c))

"""
在上述示例中，首先创建了一个生成器对象 c，然后使用 next() 方法获取其第一个元素，输出为 0。
接下来，使用 send() 方法向生成器发送一个值 3，生成器会在下一次调用 yield 关键字时接收该值，并使用它来修改计数器的递增步长，从而将计数器的递增步长变为 3。
此后，再次调用 send() 方法向生成器发送一个值 5，生成器同样会在下一次调用 yield 关键字时接收该值，
并使用它来更新计数器的递增步长，从而将计数器的递增步长变为 5。最后，使用 next() 方法获取生成器中的下一个元素，输出为 13，这是计数器的当前值。
"""

print('------------------------------------------------分隔符1--------------------------------------------------------')


# 举例2
def gen():
    i = 0
    while i < 5:
        temp = yield i
        print('temp: ', temp)
        i += 1
    return '没有更多数据'


g1 = gen()

print(g1.send(None))
print(g1.send('hehe'))
print(g1.send('haha'))

print('---------------------------------------------------分隔符2--------------------------------------------------')

# 举例3

def generate_numbers():
    num = 0
    while True:
        received = yield num
        if received is not None:
            num = received
        else:
            num += 1

"""
这个函数是一个生成器，每次调用 next() 方法时会返回一个数字，同时可以使用 send() 方法来发送一个新的值给生成器，从而控制生成器中的数值变化。
具体来说，这个生成器首先定义了一个变量 num，然后进入一个无限循环，在循环中每次使用 yield 返回当前的 num 值，
同时通过 received = yield num 语句将外部发送给生成器的值存储到 received 变量中。
接着，如果接收到了一个非空的值，就将 num 的值设为该值，否则将 num 值加 1。这样，我们就可以通过发送新的值给生成器来控制生成器中的数字变化。
"""

# 创建生成器对象
gen = generate_numbers()

# 调用 next() 方法，返回 0
print(next(gen))  # 输出 0

# 使用 send() 方法发送 5，将生成器中的值设为 5
gen.send(5)

# 再次调用 next() 方法，返回 5
print(next(gen))  # 输出 5

# 再次使用 send() 方法发送 10，将生成器中的值设为 10
gen.send(10)

# 再次调用 next() 方法，返回 10
print(next(gen))  # 输出 10


"""
在这个例子中，我们首先创建了一个生成器对象 gen，然后使用 next() 方法调用生成器，第一次调用时返回的是 num 的初始值 0。
接着，我们使用 gen.send(5) 发送了一个值 5 给生成器，从而将 num 值设为 5。
再次调用 next() 方法时，生成器会返回 5。然后，我们又使用 gen.send(10) 发送了一个值 10 给生成器，从而将 num 值设为 10。
最后一次调用 next() 方法时，生成器会返回 10。这样，我们就通过 send() 方法来控制了生成器中的数字变化。
"""





